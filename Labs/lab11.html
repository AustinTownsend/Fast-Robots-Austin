<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../styles.css" />
    <title>Lab 11</title>
  </head>
  <body>
    <header>
      <h1>Fast Robots - Austin Townsend</h1>
      <nav>
        <ul>
          <li><a href="https://austintownsend.github.io/Fast-Robots-Austin/index.html">Home</a></li>
          <li><a href="lab1A.html">Lab 1A</a></li>
          <li><a href="lab1B.html">Lab 1B</a></li>
          <li><a href="lab2.html">Lab 2</a></li>
          <li><a href="lab3.html">Lab 3</a></li>
          <li><a href="lab4.html">Lab 4</a></li>
          <li><a href="lab5.html">Lab 5</a></li>
          <li><a href="lab6.html">Lab 6</a></li>
          <li><a href="lab7.html">Lab 7</a></li>
          <li><a href="lab8.html">Lab 8</a></li>
          <li><a href="lab9.html">Lab 9</a></li>
          <li><a href="lab10.html">Lab 10</a></li>
          <li><a href="lab11.html">Lab 11</a></li>
        </ul>
      </nav>
    </header>

    <section class="content">
      <h2>Lab 11</h2>

      <p>
        The purpose of this lab is perform localization with the Bayes filter
        on the physical robot. The Bayes filter will make a belief about where
        the robot is based on a full 360 degree spin at each of the locations.
      </p>

      <h3>Localization in Simulation</h3>

      <p>
        The first task of the lab was to run the simulation and ensure the provided
        code all worked properly. This is the corrected code from Lab 10, and the
        procedure is roughly the exact same. A picture of the plot is shown below
        to prove that the code and simulation is working correctly.
      </p>

      <img src="TEST LOC SIM.png" alt="test lcoalization sim map" width="700" />

      <h3>Implementation on Robot</h3>

      <p>
        While most of the code was provided for us, we were responsible for implementing
        the PID orientation control. This was taken from Lab 9, and the only thing
        I needed to adjust was to have it spin every 20 degrees instead of 10.
        However, my code from Lab 9 collects more than 18 data points, and the provided
        code can only handle 18 points, one from each angle. In order to fix this
        issue, I added a secondary post-processing step that extracts the ToF value
        at each of the desired angles from 0 to 340 degrees. The full code is shown
        below.
      </p>

      <img src="OBSERVE LOOP.png" alt="observation loop code" width="700" />

      <h3>Odomoetry Motion Model</h3>

      <p>
        This code uses a gaussian distribution to determine the probability that
        the robot actually moved based on the input control. This process is repeated
        for each movement described above, and then the probabilities are multiplied
        together to get an overall probability. The code is shown below.
      </p>

      <img src="BAYES ODOM.png" alt="bayes odom" width="700" />

      <h3>Prediction Step</h3>

      <p>
        The prediction code predicts the probability that the robot will be at some
        state given its belief it was at the previous state and underwent the given
        control input. Rather then setting a belief of 0 to 0, I used a value of
        0.0001 in order to prevent issues with the probabilities. The code is shown
        below.
      </p>

      <img src="BAYES PREDICT.png" alt="bayes predict" width="700" />

      <h3>Sensor Model</h3>

      <p>
        This function runs through 18 different measurements to determine the
        probability of a sensor measurement given the current position. Overall,
        this code defines the probability that is used in other functions. The code
        is shown below.
      </p>

      <img src="BAYES SENSOR.png" alt="bayes sensor" width="700" />

      <h3>Update Step</h3>

      <p>
        This function takes the predicted belief (bel_bar), and it updates the
        belief based on the sensor input value. This is done by multiplying the
        probability from the measurement and the predicted belief state. Then, the
        value is normalized to keep the sum of the probabilities equal to one. The
        code is shown below,
      </p>

      <img src="BAYES UPDATE.png" alt="bayes update" width="700" />

      <h3>Simulation Results</h3>

      <p>
        The simulation results are shown below. The odomoetry model (shown in red)
        is very inaccurate. However, the true results (shown in green) and the
        belief results (shown in blue) are pretty close. This means that the
        prediction from the Bayes filter is pretty good and converges nicely. While
        the filter did stray a little at a few of the points, it was able to get
        itself back on track quickly.
      </p>

      <img src="SIM MAP.png" alt="sim map" width="500" />
      <img src="BAYES MAP.png" alt="bayes map" width="600" />

      <h3>Lab 11 Takeaways</h3>

      <p>
        I learned a lot about Bayes filter and its possible implications for my
        robot. I look forward to implementing it in the next lab to help with
        physical localization.
      </p>

    </section>
  </body>
</html>
