<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../styles.css" />
    <title>Lab 6</title>
  </head>
  <body>
    <header>
      <h1>Fast Robots - Austin Townsend</h1>
      <nav>
        <ul>
          <li><a href="https://austintownsend.github.io/Fast-Robots-Austin/index.html">Home</a></li>
          <li><a href="lab1A.html">Lab 1A</a></li>
          <li><a href="lab1B.html">Lab 1B</a></li>
          <li><a href="lab2.html">Lab 2</a></li>
          <li><a href="lab3.html">Lab 3</a></li>
          <li><a href="lab4.html">Lab 4</a></li>
          <li><a href="lab5.html">Lab 5</a></li>
          <li><a href="lab6.html">Lab 6</a></li>
        </ul>
      </nav>
    </header>

    <section class="content">
      <h2>Lab 6</h2>

      <p>

      </p>

      <h3>Prelab</h3>

      <p>
        This prelab is identical to the prelab from Lab 5. My method for sending
        and receiving data via Bluetooth is the same. I implemented additional
        helper functions in Arduino to help compute the orientation control separate
        from the linear control.
      </p>

      <h3>Orientation Control</h3>

      <p>
        The goal of this lab is to have the RC car correct itself to a desired
        angle. By using PID control, the car can quickly reach its target goal
        as well as minimize steady state error and overshoot. Much like the linear
        control from Lab 5, this will be an iterative process. In order to gather
        orientation data of the RC car, we will use the onboard gyroscope on the
        IMU. This IMU was developed in lab 2, so much of the backend issues have
        already been dealt with. The basis of this lab will be to replace all
        TOF data collection with IMU yaw data, since yaw is the only rotational
        axis that we care about for spinning the RC car. Additionally, since we
        want the car to rotate instead of move forwards or backwards, the wheels
        will now be spinning in opposite directions. The portion of my main loop
        that deals with orientation as well as the case that turns on the flag
        to begin orientation PID control are shown below.
      </p>

      <img src="START ORIENT CASE.png" alt="START ORIENT" width="400" />
      <img src="ORIENT CODE BODY.png" alt="ORIENT CODE" width="400" />

      <h3>Sampling Frequency</h3>

      <p>
        The IMU is able to collect data at a much faster rate than the TOF sensors.
        Instead of 100 ms like in lab 5, we are able to gather new yaw data every
        4 ms. This means the limiting factor is the PID control, rather than the
        sampling sensor.
      </p>

      <h3>PID Implementation</h3>

      <p>
        The first step is to guess an initial proportional gain (KP), and see how
        the RC car reacts. For my tests, I will be setting the target angle to 180
        degrees, meaning we expect the RC car to be able to turn around and settle
        facing the opposite direction. After several trials, I found that a KP value
        of 4 was optimal. This allowed the car to settle within a second and had
        minimal oscillation issues. Regardless, these oscillations will be removed
        when the derivative control is implemented. A video of the P controller
        as well as the accompanying plot of angle, P, and PID over time are shown
        below.
      </p>

      <iframe width="650" height="400" src="https://www.youtube.com/embed/56n_whedgjA"
      title="Both Motor Test" frameborder="0" allow="accelerometer; autoplay;
      clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen> </iframe>
      <img src="P ORIENT.png" alt="P ORIENT PLOT" width="500" />

      <p>
        One issue that I started to run in to was that the minimum PWM value for
        rotation is much higher than that of linear movement. This means that I
        had to adjust the deadband threshold from 25 to 40. This increase of lower
        limit allowed the RC car to make finer angle adjustments as the error
        decreased and PWM value decreased. Otherwise, the wheels would not have
        enough power to rotate at such low PWM inputs.
      </p>

      <p>
        Once I was confident in my P controller, the next step was to move to the
        integral term. This also required some trial and error, as the integral
        term will add extra overshoot and decrease the rise time. However, these
        will also be issues that can be mitigated by implementation of the derivative
        gain at the end. For the orientation control, I found that a gain of 0.3
        was most optimal. A video of the PI controller as well as the accompanying
        plot of angle, P, I, and PID over time are shown below.
      </p>

      <iframe width="650" height="400" src="https://www.youtube.com/embed/1ddYeph4f50"
      title="Both Motor Test" frameborder="0" allow="accelerometer; autoplay;
      clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen> </iframe>
      <img src="PI ORIENT.png" alt="PI ORIENT PLOT" width="500" />

      <p>
        The final step was to implement the derivative gain and finalize the PID
        controller. I started at a relatively low value of 0.1, and after a few
        trials, concluded with a value of 0.3. This KD value successfully eliminated
        all overshoot while also decreasing the initial rise time to under half
        a second. A video of the PID controller as well as the accompanying plot
        of angle, P, I, D, and PID over time are shown below.
      </p>

      <iframe width="650" height="400" src="https://www.youtube.com/embed/vQ4TRIvTMdQ"
      title="Both Motor Test" frameborder="0" allow="accelerometer; autoplay;
      clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
      allowfullscreen> </iframe>
      <img src="PID ORIENT.png" alt="PID ORIENT PLOT" width="500" />

      <h3>IMU Degrees Per Second</h3>

      <p>
        In order to validate the PID controller, I ran the wall test three times
        to ensure accurate and repeatable data. The three videos are shown below.
        In each trial, the car started about 1100 mm away from the wall (carboard
        box), and it finished exactly 1 foot away from the box (+/- a few mms).
        The three plots of TOF sensor with respect to time are also shown below.
      </p>

      <img src="DPS IMU.png" alt="DPS IMU" width="500" />

      <h3>Frequency Discussion</h3>

      <p>
        As found during Lab 3, my TOF sensors return data about every 100 ms. While
        it is relatively fast, it is still the limiting factor when it comes to
        our Arduino loop, which runs every 10 ms. When running the PID control
        regardless if the TOF sensor data is ready to be collected, I found that
        the PID control runs about every 8 ms. This is considerably faster than
        the 100 ms from the TOF sensor.
      </p>

      <h3>Linear Extrapolation</h3>

      <p>
        Linear extrapolation is implemented because the sampling frequency for
        the PID controller is much faster than the TOF sensors. This means that
        we want to estimate the distance when the TOF is not yet ready to gather
        new data. In order to do this, we will take the difference between the
        past two TOF data points and solve for the slope by dividing by the dt
        value. Then, we will multiply this slope by the PID sampling rate (PID_dt)
        to estimate the current distance from the target. This is a simple linear
        extrapolation algorithm that will hopefully allow or PID to be more accurate.
        My code demonstrating this extrapolation is shown below.
      </p>

      <img src="LINEAR EXTRAP.png" alt="linear extrapolation code" width="500" />

      <h3>Additional Task: Wind-Up Protection</h3>

      <p>
        The integral wind-up can be a huge issue. Because the motors can only range
        from 0-255, once the PWM signal hits 255, the system becomes saturated.
        The integral value might continue to rise, yet it will not impact the system.
        However, when the integral value goes to decrease when the RC car has overshot
        its desired value and the error becomes negative, it might not be able to
        accurately unwind due to its large built up positive error. To prevent
        this, I implemented a cap on the integral value. This means that when the
        integral component reaches +/- 100, it becomes manually set to +/- 100.
        This prevents the integral value from running too high or too low and messing
        up the rest of the system.
      </p>

      <h3>Lab 6 Takeaways</h3>

      <p>

      </p>

    </section>
  </body>
</html>
