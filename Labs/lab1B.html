<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../styles.css" />
    <title>Lab 1B</title>
  </head>
  <body>
    <header>
      <h1>Fast Robots - Austin Townsend</h1>
      <nav>
        <ul>
          <li><a href="https://austintownsend.github.io/Fast-Robots-Austin/index.html">Home</a></li>
          <li><a href="lab1A.html">Lab 1A</a></li>
          <li><a href="lab1B.html">Lab 1B</a></li>
          <li><a href="lab2.html">Lab 2</a></li>
          <li><a href="lab3.html">Lab 3</a></li>
          <li><a href="lab4.html">Lab 4</a></li>
          <li><a href="lab5.html">Lab 5</a></li>
          <li><a href="lab6.html">Lab 6</a></li>
          <li><a href="lab7.html">Lab 7</a></li>
          <li><a href="lab8.html">Lab 8</a></li>
          <li><a href="lab9.html">Lab 9</a></li>
        </ul>
      </nav>
    </header>

    <section class="content">
      <h2>Lab 1B</h2>

      <p>
        The purpose of this lab is to establish Bluetooth connection between the
        Artemis and our personal computers. Using Jupyter and Arduino IDE together,
        we will be able to send and receive data using BLE that we will be able
        to build on for future labs.
      </p>

      <h3>Prelab</h3>

      <p>
        The prelab consisted of installing all necessary software to establish
        an initial Bluetooth connection. Once Python was installed, the next step
        was to establish a virtual environment that we could run all of our scripts
        through. This helps to keep all the files in a single location as well as
        protect our personal computers if anything were to go wrong. Then, once
        the Jupyter lab was up and running, we could update the Artemis's MAC
        address and create a unique UUID. Finally, once updating the command types
        and config file, we were read to start the introductory tasks in the lab.
      </p>

      <h3>Task 1: ECHO</h3>

      <p>
        The first task was to create an ECHO command that would send a string
        from our computer to the Artemis board, and in response, the Artemis would
        send back a string to the computer. Below is the ECHO case that was written
        on the Artemis board.
      </p>

      <img src="ECHO Case.jpg" alt="Echo Case" width="500" />

      <p>
        In order to send and receive the string, the following code was written
        in the Jupyter notebook. In this example, the sent message was "HiHello",
        and the reply from the robot was "Robot says --> HiHello :)".
      </p>

      <img src="ECHO Call.jpg" alt="Echo Call" width="400" />

      <h3>Task 2: GET_TIME_MILLIS</h3>

      <p>
        The second task was to create a command that would make the Artemis reply
        with a string that was the current time in milliseconds. This utilizes a
        built in function millis() that tracks the amount of time since the Artemis
        was powered on. Below is the GET_TIME_MILLIS case that was written on the
        Artemis board.
      </p>

      <img src="GET TIME MILLIS Case.jpg" alt="Get time millis Case" width="500" />

      <p>
        In order to send and receive the string, the following code was written
        in the Jupyter notebook.
      </p>

      <img src="GET TIME MILLIS Call.jpg" alt="Get time millis Call" width="400" />

      <h3>Task 3: Notification Handler</h3>

      <p>
        The next task was to write a notification handler that would help extract
        the time from the Artemis board. The purpose of a notification handler
        is to constantly be listening to the Artemis and send the desired information
        when the command is called. The image below shows the basic notification
        handler that I wrote to extract the time, in seconds, since the Artemis
        was powered on.
      </p>

      <img src="NOTIFICATION HANDLER Call.jpg" alt="Echo Case" width="500" />

      <h3>Task 4: GET_TIME_MILLIS_LOOP</h3>

      <p>
        This next task builds off of the past two tasks by using a new notification
        handler to get the current time in milliseconds multiple times for a few
        seconds. By collecting the time stamps, we are able to see how quickly
        the Artemis can send messages to the computer. The code for the case
        written on Artemis is shown below.
      </p>

      <img src="GET TIME MILLIS LOOP Case.png" alt="Get time millis loop Case" width="500" />

      <p>
        In order to receive the time stamps, the following code was written
        in the Jupyter notebook. A few of the timestamps are also shown below.
        Using these values, we can calculate that the Artemis can send about 148
        messages per second. Since each message is about 14 bytes, we can say that
        the effective data transfer rate of this method is 2074 bytes per second.
      </p>

      <img src="GET TIME MILLIS LOOP Call.png" alt="Get time millis loop Call" width="400" />

      <h3>Task 5: Time Stamp Array</h3>

      <p>
        This task provides a new method for receiving data from the Artemis board.
        Instead of sending each message as it is called, the time stamps are stored
        in an array, and after a certain amount of time, the entire array is sent
        at once to the computer. I wrote two cases for this task: one to store the
        data in the array and another to send the array to the computer. The two
        cases are shown below.
      </p>

      <img src="STORE TIME DATA Case.png" alt="Store time data Case" width="400" />
      <img src="SEND TIME DATA Case.png" alt="Send time data Case" width="550" />

      <p>
        The commands to call these cases are shown below. As seen by the time stamps,
        the messages are able to be sent in closer succession since there is no
        lost time due to sending the message after each collection.
      </p>

      <img src="TIME ARRAY Call.png" alt="Time array Call" width="400" />

      <h3>Task 6: Time Stamp Array</h3>

      <p>
        In this task, we are building off of the time array from the previous task
        by adding an additional array to collect the temperature reading as well.
        The output will then be a given temperature with a corresponding time stamp.
        The command, GET_TEMP_READINGS, both sets the arrays and sends the arrays
        to the computer after a given time period. It utilizes the built in
        getTempDegC() function to collect the temperature. The code is shown below.
      </p>

      <img src="GET TEMP READING Case.png" alt="Get temp reading Case" width="400" />

      <p>
        This task also utilizes a new notification handler that handles both time
        and temperature. The new notification handler is shown below. The command
        to call this case is also shown below. It also includes a few of the
        received messages to show the time stamp and temperature reading.
      </p>

      <img src="TEMP NOTIFICATION HANDLER Call.png" alt="Temp notification handler call" width="400" />
      <img src="GET TEMP READING Call.png" alt="Get temp reading Call" width="400" />

      <h3>Task 7: Advantages & Disadvantages of Array Method</h3>

      <p>
        The advantages of using the array method is that you can collect data at
        a faster rate than without using the array method. This enables the Artemis
        to save time because it does not need to send data after each collection
        cycle. A potential disadvantage is that the array has a finite length,
        and you need to include a counter in order to correctly assess the correct
        length at each moment. Additionally, the Artemis's storage will fill up
        much faster than without using the array method. For the array method,
        based on the time stamps from Task 5, effective data transfer rate is
        61.6 kB per second. Based on the Artemis board's 384 kB of RAM, you can
        store data for about 6.23 seconds before needing to send the data.
      </p>

      <h3>Additional Task: Effective Data Rate And Overhead</h3>

      <p>
        For this task, we were asked to note the respective times for sending and
        receiving small messages, such as 5-byte messages, and large messages,
        such as 120-byte messages. In intuition, the larger byte messages should
        take longer to send. This is because with more bytes to write, it should
        take longer for the Artemis to send the full communication. The graph below,
        however, shows that the difference is only slightly different between
        small and large messages. Using the expected trend mentioned earlier,
        I would say that larger replies help to reduce overhead, and many small
        messages introduce a lot more overhead. A plot is shown below of my results.
      </p>

      <img src="NOTIFICATION HANDLER OVERHEAD Call.png" alt="Notification handler overhead call" width="400" />
      <img src="OVERHEAD Call.png" alt="Overhead Call" width="400" />
      <img src="OVERHEAD PLOT.png" alt="Overhead Plot" width="400" />

      <h3>Additional Task: Reliability</h3>

      <p>
        In order to test reliability, I changed the amount of messages sent. In
        this process, I tracked the messages sent and messages received, and they
        perfectly matched up. This means that no data was missing, and the Artemis
        communicated reliably with the computer.
      </p>

      <h3>Lab 1B Takeaways</h3>

      <p>
        This lab was extremely useful as an introduction to communication via
        Bluetooth between the computer and Artemis board. This was also a good
        introduction to notification handlers and the potential uses moving forward
        in this course. One challenge from this lab was trying to track time on
        both the Artemis and computer at the same time in order to have correct
        time stamps. However, as a whole, this lab was worthwhile and a great
        building block for future labs to come.
      </p>

    </section>
  </body>
</html>
